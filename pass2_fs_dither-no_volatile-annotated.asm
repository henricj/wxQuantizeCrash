; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.24728.0 

	TITLE	C:\src\Audio\trash\crash\wxQuantizeCrash\pass2_fs_dither.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?pass2_fs_dither@@YAXPAUj_decompress@@PAPAE1H@Z	; pass2_fs_dither
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??_C@_06GBCBHGBN@?5cur2?5?$AA@			; `string'
PUBLIC	??_C@_06GDGHMIEE@?5cur1?5?$AA@			; `string'
PUBLIC	??_C@_06GCKFKCHD@?5cur0?5?$AA@			; `string'
PUBLIC	??_C@_05GNPMFFOH@?5row?5?$AA@			; `string'
PUBLIC	??_C@_04FAEDPEMM@col?5?$AA@			; `string'
PUBLIC	??_C@_0BE@NLCBIGHG@?5?5?5post?9error?5cur0?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@GEIBNLID@?5?5?5post?9range?5cur0?5?$AA@ ; `string'
PUBLIC	??_C@_0BH@HPLHMIKO@?5?5?5post?9colormap?5cur0?5?$AA@ ; `string'
PUBLIC	??_C@_0M@DHKLIJJ@?5bpreverr2?5?$AA@		; `string'
PUBLIC	??_C@_0M@BDMAGMA@?5bpreverr1?5?$AA@		; `string'
PUBLIC	??_C@_0BM@MFMONLHK@?5?5?5post?9colormap?5bpreverr0?5?$AA@ ; `string'
PUBLIC	??_C@_0M@JBEIHMKK@?5belowerr2?5?$AA@		; `string'
PUBLIC	??_C@_0M@JDAOMCPD@?5belowerr1?5?$AA@		; `string'
PUBLIC	??_C@_0BM@FHPMBPEJ@?5?5?5post?9colormap?5belowerr0?5?$AA@ ; `string'
PUBLIC	??_C@_0O@MNIGOHNE@?5?5?5last?5cur0?5?$AA@	; `string'
EXTRN	___std_terminate:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	?fill_inverse_cmap@@YAXPAUj_decompress@@HHH@Z:PROC ; fill_inverse_cmap
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0O@MNIGOHNE@?5?5?5last?5cur0?5?$AA@
CONST	SEGMENT
??_C@_0O@MNIGOHNE@?5?5?5last?5cur0?5?$AA@ DB '   last cur0 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FHPMBPEJ@?5?5?5post?9colormap?5belowerr0?5?$AA@
CONST	SEGMENT
??_C@_0BM@FHPMBPEJ@?5?5?5post?9colormap?5belowerr0?5?$AA@ DB '   post-col'
	DB	'ormap belowerr0 ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDAOMCPD@?5belowerr1?5?$AA@
CONST	SEGMENT
??_C@_0M@JDAOMCPD@?5belowerr1?5?$AA@ DB ' belowerr1 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBEIHMKK@?5belowerr2?5?$AA@
CONST	SEGMENT
??_C@_0M@JBEIHMKK@?5belowerr2?5?$AA@ DB ' belowerr2 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MFMONLHK@?5?5?5post?9colormap?5bpreverr0?5?$AA@
CONST	SEGMENT
??_C@_0BM@MFMONLHK@?5?5?5post?9colormap?5bpreverr0?5?$AA@ DB '   post-col'
	DB	'ormap bpreverr0 ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BDMAGMA@?5bpreverr1?5?$AA@
CONST	SEGMENT
??_C@_0M@BDMAGMA@?5bpreverr1?5?$AA@ DB ' bpreverr1 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DHKLIJJ@?5bpreverr2?5?$AA@
CONST	SEGMENT
??_C@_0M@DHKLIJJ@?5bpreverr2?5?$AA@ DB ' bpreverr2 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HPLHMIKO@?5?5?5post?9colormap?5cur0?5?$AA@
CONST	SEGMENT
??_C@_0BH@HPLHMIKO@?5?5?5post?9colormap?5cur0?5?$AA@ DB '   post-colormap'
	DB	' cur0 ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEIBNLID@?5?5?5post?9range?5cur0?5?$AA@
CONST	SEGMENT
??_C@_0BE@GEIBNLID@?5?5?5post?9range?5cur0?5?$AA@ DB '   post-range cur0 '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLCBIGHG@?5?5?5post?9error?5cur0?5?$AA@
CONST	SEGMENT
??_C@_0BE@NLCBIGHG@?5?5?5post?9error?5cur0?5?$AA@ DB '   post-error cur0 '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAEDPEMM@col?5?$AA@
CONST	SEGMENT
??_C@_04FAEDPEMM@col?5?$AA@ DB 'col ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GNPMFFOH@?5row?5?$AA@
CONST	SEGMENT
??_C@_05GNPMFFOH@?5row?5?$AA@ DB ' row ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GCKFKCHD@?5cur0?5?$AA@
CONST	SEGMENT
??_C@_06GCKFKCHD@?5cur0?5?$AA@ DB ' cur0 ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGHMIEE@?5cur1?5?$AA@
CONST	SEGMENT
??_C@_06GDGHMIEE@?5cur1?5?$AA@ DB ' cur1 ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBCBHGBN@?5cur2?5?$AA@
CONST	SEGMENT
??_C@_06GBCBHGBN@?5cur2?5?$AA@ DB ' cur2 ', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$11
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 141  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 142  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 129  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 132  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 133  : 
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 122  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN2@sentry
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 124  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	mov	BYTE PTR [edi+4], al

; 126  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 98   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 99   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 983  : 	{	// insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 984  : 	_Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 985  : 	_Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 986  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 987  : 	}

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
$T2 = -28						; size = 1
$T3 = -28						; size = 1
__Count$2$ = -24					; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 772  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 775  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi
	mov	DWORD PTR __State$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR [edi+1]
$LL89@operator:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL89@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	ebx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	sub	edi, ecx
	mov	DWORD PTR __Count$2$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	test	edx, edx
	jl	SHORT $LN17@operator
	jg	SHORT $LN90@operator
	test	eax, eax
	je	SHORT $LN17@operator
$LN90@operator:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	test	edx, edx
	jl	SHORT $LN17@operator
	jg	SHORT $LN91@operator
	cmp	eax, edi
	jbe	SHORT $LN17@operator
$LN91@operator:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	mov	edi, eax
	mov	ebx, edx
	sub	edi, DWORD PTR __Count$2$[ebp]
	sbb	ebx, esi
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	ebx, DWORD PTR __Pad$[ebp+4]
	mov	edi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 98   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR __Ok$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN32@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN32@operator:

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 79   : 		return (_Tiestr);

	mov	edx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	al, al
	je	SHORT $LN28@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 79   : 		return (_Tiestr);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+60]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN28@operator
	cmp	ecx, edx
	je	SHORT $LN28@operator

; 124  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN28@operator:

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	mov	BYTE PTR __Ok$[ebp+4], al

; 778  : 		? 0 : _Ostr.width() - _Count;
; 779  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 780  : 
; 781  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 782  : 		_State |= ios_base::badbit;

	mov	esi, 4

; 783  : 	else

	jmp	$LN101@operator
$LN8@operator:

; 784  : 		{	// state okay, insert
; 785  : 		_TRY_IO_BEGIN
; 786  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN86@operator
	npad	4
$LL4@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jl	SHORT $LN3@operator
	jg	SHORT $LN92@operator
	test	edi, edi
	je	SHORT $LN3@operator
$LN92@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 112  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 112  : 		return (_Fillch);

	mov	BYTE PTR $T3[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd

; 542  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	jne	SHORT $LN93@operator

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	test	esi, esi

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN86@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	mov	ecx, DWORD PTR [eax+ecx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN93@operator
	test	edx, edx
	jne	SHORT $LN93@operator
	npad	1
$LL95@operator:

; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jl	SHORT $LN6@operator
	jg	SHORT $LN94@operator
	test	edi, edi
	je	SHORT $LN6@operator
$LN94@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 112  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios

; 112  : 		return (_Fillch);

	mov	BYTE PTR $T2[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd

; 542  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 802  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 803  : 					{	// insertion failed, quit
; 804  : 					_State |= ios_base::badbit;

	or	esi, 4

; 805  : 					break;

	jmp	SHORT $LN102@operator
$LN5@operator:

; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LL95@operator
$LN93@operator:

; 797  : 			_State |= ios_base::badbit;

	mov	esi, 4
$LN102@operator:
	mov	DWORD PTR __State$[ebp], esi
$LN6@operator:

; 806  : 					}
; 807  : 		_Ostr.width(0);

	mov	ebx, DWORD PTR __Ostr$[ebp]
	push	0
	push	0
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN22@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 808  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ios
	mov	esi, DWORD PTR __State$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN101@operator:
	mov	ebx, DWORD PTR __Ostr$[ebp]
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\ostream

; 809  : 		}
; 810  : 
; 811  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	esi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 129  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 132  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN69@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN69@operator:

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+esi+56]
	test	ecx, ecx
	je	SHORT $LN96@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN96@operator:

; 812  : 	return (_Ostr);

	mov	eax, ebx

; 813  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\src\audio\trash\crash\wxquantizecrash\pass2_fs_dither.cpp
;	COMDAT ?pass2_fs_dither@@YAXPAUj_decompress@@PAPAE1H@Z
_TEXT	SEGMENT
_cquantize$1$ = -108					; size = 4
tv722 = -104						; size = 4
_colormap2$1$ = -100					; size = 4
_colormap1$1$ = -96					; size = 4
_colormap0$1$ = -92					; size = 4
_bnexterr$1$ = -88					; size = 4
_cachep$1$ = -88					; size = 4
_histogram$1$ = -84					; size = 4
tv721 = -80						; size = 4
tv723 = -76						; size = 4
_width$1$ = -72						; size = 4
_dir$1$ = -68						; size = 4
_range_limit$1$ = -64					; size = 4
_error_limit$1$ = -60					; size = 4
_row$1$ = -56						; size = 4
_col$1$ = -52						; size = 4
_dir3$1$ = -48						; size = 4
_belowerr2$1$ = -44					; size = 4
_belowerr1$1$ = -40					; size = 4
_belowerr0$1$ = -36					; size = 4
_bpreverr2$1$ = -32					; size = 4
_bpreverr1$1$ = -28					; size = 4
_bpreverr0$1$ = -24					; size = 4
_outptr$1$ = -20					; size = 4
_inptr$1$ = -16						; size = 4
_cur2$2$ = -12						; size = 4
_cur2$1$ = -12						; size = 4
_cur1$2$ = -8						; size = 4
_cur0$2$ = -4						; size = 4
_cinfo$ = 8						; size = 4
_input_buf$ = 12					; size = 4
_output_buf$ = 16					; size = 4
_num_rows$ = 20						; size = 4
?pass2_fs_dither@@YAXPAUj_decompress@@PAPAE1H@Z PROC	; pass2_fs_dither, COMDAT

; 8    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 9    : 	my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;
; 10   : 	hist3d histogram = cquantize->histogram;
; 11   : 
; 12   : 	// Making the curN variables "volatile" lets the optimizing compiler
; 13   : 	// generate code that generates the same output as when the optimizer
; 14   : 	// is disabled.
; 15   : #if 0
; 16   : 	volatile
; 17   : #endif
; 18   : 	LOCFSERROR cur0, cur1, cur2; /* current error or pixel value */
; 19   : 	LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
; 20   : 	LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
; 21   : 	FSERRPTR errorptr;   /* => fserrors[] at column before current */
; 22   : 	JSAMPROW inptr;       /* => current input pixel */
; 23   : 	JSAMPROW outptr;      /* => current output pixel */
; 24   : 	histptr cachep;
; 25   : 	int dir;          /* +1 or -1 depending on direction */
; 26   : 	int dir3;         /* 3*dir, for advancing inptr & errorptr */
; 27   : 	int row;
; 28   : 	JDIMENSION col;
; 29   : 	JDIMENSION width = cinfo->output_width;
; 30   : 	JSAMPLE *range_limit = cinfo->sample_range_limit;
; 31   : 	int *error_limit = cquantize->error_limiter;
; 32   : 	JSAMPROW colormap0 = cinfo->colormap[0];
; 33   : 	JSAMPROW colormap1 = cinfo->colormap[1];
; 34   : 	JSAMPROW colormap2 = cinfo->colormap[2];
; 35   : 
; 36   : 
; 37   : 	for (row = 0; row < num_rows; row++) {

	cmp	DWORD PTR _num_rows$[ebp], 0
	mov	eax, DWORD PTR _cinfo$[ebp]
	push	ebx
	mov	DWORD PTR _row$1$[ebp], 0
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _cquantize$1$[ebp], ebx
	mov	DWORD PTR _width$1$[ebp], edx
	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR _histogram$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _range_limit$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR _error_limit$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _colormap0$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _colormap1$1$[ebp], ecx
	mov	DWORD PTR _colormap2$1$[ebp], eax
	jle	$LN3@pass2_fs_d
	mov	eax, DWORD PTR _input_buf$[ebp]
	mov	ecx, DWORD PTR _output_buf$[ebp]
	sub	eax, ecx
	push	esi
	mov	DWORD PTR _input_buf$[ebp], eax
	push	edi
	npad	7
$LL4@pass2_fs_d:

; 38   : 		inptr = input_buf[row];
; 39   : 		outptr = output_buf[row];
; 40   : 		if (cquantize->on_odd_row) {

	cmp	BYTE PTR [ebx+36], 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR _inptr$1$[ebp], eax
	mov	DWORD PTR _outptr$1$[ebp], esi
	je	SHORT $LN8@pass2_fs_d

; 41   : 			/* work right to left in this row */
; 42   : 			inptr += (width - 1) * 3;   /* so point to rightmost pixel */

	add	eax, edx

; 43   : 			outptr += width - 1;
; 44   : 			dir = -1;

	mov	DWORD PTR _dir$1$[ebp], -1
	dec	esi

; 45   : 			dir3 = -3;

	mov	DWORD PTR _dir3$1$[ebp], -3		; fffffffdH

; 46   : 			errorptr = cquantize->fserrors + (width + 1) * 3; /* => entry after last column */

	lea	ecx, DWORD PTR [edx+1]

; 47   : 			cquantize->on_odd_row = false; /* flip for next time */

	mov	BYTE PTR [ebx+36], 0
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+edx*2]
	add	eax, -3					; fffffffdH
	add	esi, edx
	mov	DWORD PTR _inptr$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR _outptr$1$[ebp], esi
	lea	esi, DWORD PTR [eax+ecx*2]

; 48   : 		}
; 49   : 		else {

	mov	ecx, DWORD PTR _output_buf$[ebp]
	jmp	SHORT $LN9@pass2_fs_d
$LN8@pass2_fs_d:

; 50   : 			/* work left to right in this row */
; 51   : 			dir = 1;
; 52   : 			dir3 = 3;
; 53   : 			errorptr = cquantize->fserrors; /* => entry before first real column */

	mov	esi, DWORD PTR [ebx+32]
	mov	DWORD PTR _dir$1$[ebp], 1
	mov	DWORD PTR _dir3$1$[ebp], 3

; 54   : 			cquantize->on_odd_row = true; /* flip for next time */

	mov	BYTE PTR [ebx+36], 1
$LN9@pass2_fs_d:

; 55   : 		}
; 56   : 		/* Preset error values: no error propagated to first pixel from left */
; 57   : 		cur0 = cur1 = cur2 = 0;
; 58   : 		/* and no error propagated to row below yet */
; 59   : 		belowerr0 = belowerr1 = belowerr2 = 0;
; 60   : 		bpreverr0 = bpreverr1 = bpreverr2 = 0;
; 61   : 
; 62   : 		for (col = width; col > 0; col--) {

	mov	edx, DWORD PTR _width$1$[ebp]
	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _cur0$2$[ebp], eax
	xor	edi, edi
	mov	DWORD PTR _cur2$2$[ebp], ebx
	mov	DWORD PTR _cur1$2$[ebp], edi
	mov	DWORD PTR _belowerr2$1$[ebp], eax
	mov	DWORD PTR _belowerr1$1$[ebp], eax
	mov	DWORD PTR _belowerr0$1$[ebp], eax
	mov	DWORD PTR _bpreverr2$1$[ebp], eax
	mov	DWORD PTR _bpreverr1$1$[ebp], eax
	mov	DWORD PTR _bpreverr0$1$[ebp], eax
	mov	DWORD PTR _col$1$[ebp], edx
	test	edx, edx
	je	$LN6@pass2_fs_d
	mov	ecx, DWORD PTR _dir3$1$[ebp]
	lea	edx, DWORD PTR [ecx+ecx]
	lea	ecx, DWORD PTR [ecx*2+4]
	mov	DWORD PTR tv723[ebp], edx
	mov	DWORD PTR tv721[ebp], ecx
	npad	4
$LL7@pass2_fs_d:

; 63   : 			/* curN holds the error propagated from the previous pixel on the
; 64   : 			* current line.  Add the error propagated from the previous line
; 65   : 			* to form the complete error correction term for this pixel, and
; 66   : 			* round the error term (which is expressed * 16) to an integer.
; 67   : 			* RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
; 68   : 			* for either sign of the error value.
; 69   : 			* Note: errorptr points to *previous* column's array entry.
; 70   : 			*/
; 71   : 
; 72   : 			std::cout << "col " << col << " row " << row << " cur0 " << cur0 << " cur1 " << cur1 << " cur2 " << cur2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	ebx
	push	OFFSET ??_C@_06GBCBHGBN@?5cur2?5?$AA@
	push	edi
	push	OFFSET ??_C@_06GDGHMIEE@?5cur1?5?$AA@
	push	eax
	push	OFFSET ??_C@_06GCKFKCHD@?5cur0?5?$AA@
	push	DWORD PTR _row$1$[ebp]
	push	OFFSET ??_C@_05GNPMFFOH@?5row?5?$AA@
	push	DWORD PTR _col$1$[ebp]
	push	OFFSET ??_C@_04FAEDPEMM@col?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 73   : 
; 74   : 			cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3 + 0] + 8, 4);

	mov	edx, DWORD PTR tv723[ebp]
	mov	ecx, DWORD PTR _cur0$2$[ebp]
	add	edx, esi

; 75   : 			cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3 + 1] + 8, 4);
; 76   : 			cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3 + 2] + 8, 4);
; 77   : 			/* Limit the error using transfer function set by init_error_limit.
; 78   : 			* See comments with init_error_limit for rationale.
; 79   : 			*/
; 80   : 			
; 81   : 			cur0 = error_limit[cur0];

	mov	edi, DWORD PTR _error_limit$1$[ebp]
	add	ecx, 8
	mov	DWORD PTR tv722[ebp], edx

; 82   : 			cur1 = error_limit[cur1];
; 83   : 			cur2 = error_limit[cur2];
; 84   : 
; 85   : 			std::cout << "   post-error cur0 " << cur0 << " cur1 " << cur1 << " cur2 " << cur2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	movsx	eax, WORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _cur1$2$[ebp]
	sar	eax, 4
	add	ecx, 8
	mov	edi, DWORD PTR [edi+eax*4]
	movsx	eax, WORD PTR [edx+2]
	mov	edx, DWORD PTR _error_limit$1$[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR _cur2$2$[ebp]
	sar	eax, 4
	add	ecx, 8
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR tv721[ebp]
	movsx	eax, WORD PTR [eax+esi]
	add	eax, ecx
	sar	eax, 4
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	push	OFFSET ??_C@_06GBCBHGBN@?5cur2?5?$AA@
	push	ebx
	push	OFFSET ??_C@_06GDGHMIEE@?5cur1?5?$AA@
	push	edi
	push	OFFSET ??_C@_0BE@NLCBIGHG@?5?5?5post?9error?5cur0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	DWORD PTR _cur2$1$[ebp], eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 86   : 
; 87   : 			/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
; 88   : 			* The maximum error is +- MAXJSAMPLE (or less with error limiting);
; 89   : 			* this sets the required size of the range_limit array.
; 90   : 			*/
; 91   : 			cur0 += GETJSAMPLE(inptr[0]);

	mov	edx, DWORD PTR _inptr$1$[ebp]

; 92   : 			cur1 += GETJSAMPLE(inptr[1]);
; 93   : 			cur2 += GETJSAMPLE(inptr[2]);
; 94   : 			cur0 = GETJSAMPLE(range_limit[cur0]);

	mov	ecx, DWORD PTR _range_limit$1$[ebp]

; 95   : 			cur1 = GETJSAMPLE(range_limit[cur1]);
; 96   : 			cur2 = GETJSAMPLE(range_limit[cur2]);
; 97   : 
; 98   : 			std::cout << "   post-range cur0 " << cur0 << " cur1 " << cur1 << " cur2 " << cur2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	movzx	eax, BYTE PTR [edx]
	add	eax, edi
	movzx	ecx, BYTE PTR [eax+ecx]
	movzx	eax, BYTE PTR [edx+1]
	add	eax, ebx
	mov	DWORD PTR _cur0$2$[ebp], ecx
	mov	ebx, DWORD PTR _range_limit$1$[ebp]
	movzx	edi, BYTE PTR [eax+ebx]
	movzx	eax, BYTE PTR [edx+2]
	add	eax, DWORD PTR _cur2$1$[ebp]
	mov	DWORD PTR _cur1$2$[ebp], edi
	movzx	ebx, BYTE PTR [eax+ebx]
	push	ebx
	push	OFFSET ??_C@_06GBCBHGBN@?5cur2?5?$AA@
	push	edi
	push	OFFSET ??_C@_06GDGHMIEE@?5cur1?5?$AA@
	push	ecx
	push	OFFSET ??_C@_0BE@GEIBNLID@?5?5?5post?9range?5cur0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	DWORD PTR _cur2$2$[ebp], ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 99   : 
; 100  : 			/* Index into the cache with adjusted pixel value */
; 101  : 			cachep = &histogram[cur0 >> C0_SHIFT][cur1 >> C1_SHIFT][cur2 >> C2_SHIFT];

	mov	eax, DWORD PTR _histogram$1$[ebp]
	mov	edx, edi
	mov	edi, ebx
	sar	edx, 2
	mov	ebx, DWORD PTR _cur0$2$[ebp]
	mov	ecx, edx
	sar	ebx, 3
	sar	edi, 3
	shl	ecx, 5
	add	ecx, edi
	mov	eax, DWORD PTR [eax+ebx*4]

; 102  : 			/* If we have not seen this color before, find nearest colormap */
; 103  : 			/* entry and update the cache */
; 104  : 			if (*cachep == 0)

	cmp	WORD PTR [eax+ecx*2], 0
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _cachep$1$[ebp], eax
	jne	SHORT $LN10@pass2_fs_d

; 105  : 				fill_inverse_cmap(cinfo, cur0 >> C0_SHIFT, cur1 >> C1_SHIFT, cur2 >> C2_SHIFT);

	push	edi
	push	edx
	push	ebx
	push	DWORD PTR _cinfo$[ebp]
	call	?fill_inverse_cmap@@YAXPAUj_decompress@@HHH@Z ; fill_inverse_cmap
	mov	eax, DWORD PTR _cachep$1$[ebp]
	add	esp, 16					; 00000010H
$LN10@pass2_fs_d:

; 106  : 			/* Now emit the colormap index for this cell */
; 107  : 			{ int pixcode = *cachep - 1;

	movzx	ecx, WORD PTR [eax]

; 108  : 			*outptr = (JSAMPLE)pixcode;

	mov	eax, DWORD PTR _outptr$1$[ebp]
	dec	ecx

; 109  : 			/* Compute representation error for this pixel */
; 110  : 			cur0 -= GETJSAMPLE(colormap0[pixcode]);

	mov	edx, DWORD PTR _cur0$2$[ebp]

; 111  : 			cur1 -= GETJSAMPLE(colormap1[pixcode]);

	mov	edi, DWORD PTR _cur1$2$[ebp]

; 112  : 			cur2 -= GETJSAMPLE(colormap2[pixcode]);

	mov	ebx, DWORD PTR _cur2$2$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR _colormap0$1$[ebp]

; 113  : 			}
; 114  : 			std::cout << "   post-colormap cur0 " << cur0 << " cur1 " << cur1 << " cur2 " << cur2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	mov	eax, DWORD PTR _colormap1$1$[ebp]
	mov	DWORD PTR _cur0$2$[ebp], edx
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edi, eax
	mov	eax, DWORD PTR _colormap2$1$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	ebx, eax
	push	ebx
	push	OFFSET ??_C@_06GBCBHGBN@?5cur2?5?$AA@
	push	edi
	push	OFFSET ??_C@_06GDGHMIEE@?5cur1?5?$AA@
	push	edx
	push	OFFSET ??_C@_0BH@HPLHMIKO@?5?5?5post?9colormap?5cur0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 115  : 			std::cout << "   post-colormap bpreverr0 " << bpreverr0 << " bpreverr1 " << bpreverr1 << " bpreverr2 " << bpreverr2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	DWORD PTR _bpreverr2$1$[ebp]
	push	OFFSET ??_C@_0M@DHKLIJJ@?5bpreverr2?5?$AA@
	push	DWORD PTR _bpreverr1$1$[ebp]
	push	OFFSET ??_C@_0M@BDMAGMA@?5bpreverr1?5?$AA@
	push	DWORD PTR _bpreverr0$1$[ebp]
	push	OFFSET ??_C@_0BM@MFMONLHK@?5?5?5post?9colormap?5bpreverr0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 116  : 			std::cout << "   post-colormap belowerr0 " << belowerr0 << " belowerr1 " << belowerr1 << " belowerr2 " << belowerr2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	DWORD PTR _belowerr2$1$[ebp]
	push	OFFSET ??_C@_0M@JBEIHMKK@?5belowerr2?5?$AA@
	push	DWORD PTR _belowerr1$1$[ebp]
	push	OFFSET ??_C@_0M@JDAOMCPD@?5belowerr1?5?$AA@
	push	DWORD PTR _belowerr0$1$[ebp]
	push	OFFSET ??_C@_0BM@FHPMBPEJ@?5?5?5post?9colormap?5belowerr0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 117  : 
; 118  : 			/* Compute error fractions to be propagated to adjacent pixels.
; 119  : 			* Add these into the running sums, and simultaneously shift the
; 120  : 			* next-line error sums left by 1 column.
; 121  : 			*/
; 122  : 			{ LOCFSERROR bnexterr, delta;
; 123  : 
; 124  : 			bnexterr = cur0;    /* Process component 0 */

	mov	eax, DWORD PTR _cur0$2$[ebp] ; => 21

; 125  : 			delta = cur0 * 2;
; 126  : 			cur0 += delta;      /* form error * 3 */
; 127  : 			errorptr[0] = (FSERROR)(bpreverr0 + cur0);
; 128  : 			cur0 += delta;      /* form error * 5 */
; 129  : 			bpreverr0 = belowerr0 + cur0;

	mov	ecx, DWORD PTR _belowerr0$1$[ebp] ; => 0
	mov	DWORD PTR _bnexterr$1$[ebp], eax ; => 21

; 130  : 			belowerr0 = bnexterr;
; 131  : 			cur0 += delta;      /* form error * 7 */
; 132  : 			bnexterr = cur1;    /* Process component 1 */
; 133  : 			delta = cur1 * 2;
; 134  : 			cur1 += delta;      /* form error * 3 */
; 135  : 			errorptr[1] = (FSERROR)(bpreverr1 + cur1);
; 136  : 			cur1 += delta;      /* form error * 5 */
; 137  : 			bpreverr1 = belowerr1 + cur1;
; 138  : 			belowerr1 = bnexterr;
; 139  : 			cur1 += delta;      /* form error * 7 */
; 140  : 			bnexterr = cur2;    /* Process component 2 */
; 141  : 			delta = cur2 * 2;
; 142  : 			cur2 += delta;      /* form error * 3 */
; 143  : 			errorptr[2] = (FSERROR)(bpreverr2 + cur2);
; 144  : 			cur2 += delta;      /* form error * 5 */
; 145  : 			bpreverr2 = belowerr2 + cur2;
; 146  : 			belowerr2 = bnexterr;
; 147  : 			cur2 += delta;      /* form error * 7 */
; 148  : 			}
; 149  : 			/* At this point curN contains the 7/16 error value to be propagated
; 150  : 			* to the next pixel on the current line, and all the errors for the
; 151  : 			* next line have been shifted over.  We are therefore ready to move on.
; 152  : 			*/
; 153  : 			inptr += dir3;        /* Advance pixel pointers to next column */
; 154  : 			outptr += dir;
; 155  : 			errorptr += dir3;     /* advance errorptr to current column */
; 156  : 
; 157  : 			std::cout << "   last cur0 " << cur0 << " cur1 " << cur1 << " cur2 " << cur2 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	lea	eax, DWORD PTR [eax+eax*2] ; cur0 = 3 * cur0 => 63
	lea	edx, DWORD PTR [eax+eax] ; delta? = 2 * cur0 (63) => 126 (?!?!?!?)
	mov	DWORD PTR _cur0$2$[ebp], eax  ; => 63
	add	eax, DWORD PTR _bpreverr0$1$[ebp] ; cur0 (63) + bpreverr0 (0) => 63
	mov	WORD PTR [esi], ax			; errorptr[0] => 63
	mov	eax, DWORD PTR _cur0$2$[ebp] ; => 63
	add	eax, edx ; cur0 (63) += delta? (126) => 189
	add	ecx, eax ; belowerr0 (0) += cur0 (189) => 189
	add	eax, edx ; cur0 (189) += delta (126) => 315
	mov	DWORD PTR _cur0$2$[ebp], eax ; => 315
	mov	eax, DWORD PTR _bpreverr1$1$[ebp]
	mov	DWORD PTR _bpreverr0$1$[ebp], ecx
	mov	ecx, DWORD PTR _bnexterr$1$[ebp]
	mov	DWORD PTR _belowerr0$1$[ebp], ecx
	mov	ecx, edi
	lea	edi, DWORD PTR [edi+edi*2]
	add	eax, edi
	lea	edx, DWORD PTR [edi+edi]
	mov	WORD PTR [esi+2], ax
	add	edi, edx
	mov	eax, DWORD PTR _belowerr1$1$[ebp]
	add	eax, edi
	mov	DWORD PTR _belowerr1$1$[ebp], ecx
	mov	DWORD PTR _bpreverr1$1$[ebp], eax
	mov	ecx, ebx
	mov	eax, DWORD PTR _bpreverr2$1$[ebp]
	lea	ebx, DWORD PTR [ebx+ebx*2]
	add	eax, ebx
	add	edi, edx
	mov	WORD PTR [esi+4], ax
	lea	edx, DWORD PTR [ebx+ebx]
	mov	eax, DWORD PTR _belowerr2$1$[ebp]
	add	ebx, edx
	mov	esi, DWORD PTR tv722[ebp]
	add	eax, ebx
	add	ebx, edx
	mov	DWORD PTR _bpreverr2$1$[ebp], eax
	mov	eax, DWORD PTR _inptr$1$[ebp]
	add	eax, DWORD PTR _dir3$1$[ebp]
	push	ebx
	push	OFFSET ??_C@_06GBCBHGBN@?5cur2?5?$AA@
	push	edi
	push	OFFSET ??_C@_06GDGHMIEE@?5cur1?5?$AA@
	mov	DWORD PTR _belowerr2$1$[ebp], ecx
	mov	ecx, DWORD PTR _cur0$2$[ebp]
	push	ecx
	push	OFFSET ??_C@_0O@MNIGOHNE@?5?5?5last?5cur0?5?$AA@
	push	DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	DWORD PTR _inptr$1$[ebp], eax
	mov	eax, DWORD PTR _dir$1$[ebp]
	add	DWORD PTR _outptr$1$[ebp], eax
	mov	DWORD PTR _cur1$2$[ebp], edi
	mov	DWORD PTR _cur2$2$[ebp], ebx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 55   : 		}
; 56   : 		/* Preset error values: no error propagated to first pixel from left */
; 57   : 		cur0 = cur1 = cur2 = 0;
; 58   : 		/* and no error propagated to row below yet */
; 59   : 		belowerr0 = belowerr1 = belowerr2 = 0;
; 60   : 		bpreverr0 = bpreverr1 = bpreverr2 = 0;
; 61   : 
; 62   : 		for (col = width; col > 0; col--) {

	sub	DWORD PTR _col$1$[ebp], 1
	mov	eax, DWORD PTR _cur0$2$[ebp]
	jne	$LL7@pass2_fs_d
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	ecx, DWORD PTR _output_buf$[ebp]
$LN6@pass2_fs_d:

; 158  : 		}
; 159  : 		/* Post-loop cleanup: we must unload the final error values into the
; 160  : 		* final fserrors[] entry.  Note we need not unload belowerrN because
; 161  : 		* it is for the dummy column before or after the actual array.
; 162  : 		*/
; 163  : 		errorptr[0] = (FSERROR)bpreverr0; /* unload prev errs into array */

	mov	eax, DWORD PTR _bpreverr0$1$[ebp]
	add	ecx, 4
	mov	ebx, DWORD PTR _cquantize$1$[ebp]
	mov	WORD PTR [esi], ax

; 164  : 		errorptr[1] = (FSERROR)bpreverr1;

	mov	eax, DWORD PTR _bpreverr1$1$[ebp]
	mov	WORD PTR [esi+2], ax

; 165  : 		errorptr[2] = (FSERROR)bpreverr2;

	mov	eax, DWORD PTR _bpreverr2$1$[ebp]
	mov	WORD PTR [esi+4], ax
	mov	esi, DWORD PTR _row$1$[ebp]
	mov	eax, DWORD PTR _input_buf$[ebp]
	inc	esi
	mov	DWORD PTR _row$1$[ebp], esi
	mov	DWORD PTR _output_buf$[ebp], ecx
	cmp	esi, DWORD PTR _num_rows$[ebp]
	jl	$LL4@pass2_fs_d
	pop	edi
	pop	esi
$LN3@pass2_fs_d:
	pop	ebx

; 166  : 	}
; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?pass2_fs_dither@@YAXPAUj_decompress@@PAPAE1H@Z ENDP	; pass2_fs_dither
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 552  : 		return (EOF);

	or	eax, -1

; 553  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 541  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 542  : 		return (_Left == _Right);
; 543  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.24728\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 479  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 480  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 481  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
END
